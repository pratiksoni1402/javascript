// TODO: (1). ENCAPSULATION
// Encapsulation is the practice of bundling data (attributes) and the methods (functions) that operate on that data into a single unit, which is the class. The internal workings of an object are hidden from the outside, and access to the data is controlled through well-defined interfaces (methods). Encapsulation provides data protection and organization, making it easier to manage and maintain code

class BankAccount {
    private double balance;

    public void deposit(double amount) {
        // Code to deposit money and update balance
    }

    public double getBalance() {
        // Code to retrieve balance
    }
}

// In this example, the balance data is encapsulated within the BankAccount class. External code interacts with the deposit and getBalance methods, maintaining the privacy of the balance attribute.

// TODO: (2). ABSTRACTION
// Abstraction involves creating a simplified representation of an object that only exposes the necessary details while hiding the unnecessary complexities. It focuses on the "what" rather than the "how." Abstraction allows developers to create models that capture the essential features of an object's behavior without getting into the implementation details.

abstract class Shape {
    abstract double calculateArea();
}

// In this example, the Shape class represents an abstraction of various geometric shapes. The calculateArea method is declared but not implemented, leaving the details to be defined in concrete subclasses (e.g., Circle, Rectangle).

// TODO: (3). INHERITANCE
// Inheritance is the mechanism by which one class (subclass or derived class) inherits the properties and behaviors of another class (superclass or base class). It promotes code reuse and hierarchy building. The subclass can extend or override the behaviors of the superclass, allowing for specialization and customization.

class Animal {
    void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog is barking");
    }
}

// Here, the Dog class inherits the eat method from the Animal class. It also adds a new method, bark. The inheritance relationship allows Dog to reuse the behavior of Animal and add specific behavior unique to dogs.

// TODO: (4). POLYMORPHISM
// Polymorphism allows objects of different classes to be treated as objects of a common base class. It provides the ability to perform different actions based on the actual type of object at runtime. Polymorphism is achieved through method overriding and method overloading.?

class Shape {
    void draw() {
        // Default drawing behavior
    }
}

class Circle extends Shape {
    void draw() {
        // Drawing a circle
    }
}

class Rectangle extends Shape {
    void draw() {
        // Drawing a rectangle
    }
}

// In this example, each subclass (Circle and Rectangle) overrides the draw method from the base class Shape. At runtime, you can call the draw method on a shape object, and the appropriate drawing behavior will be executed based on the actual object type.

// These four pillars of OOP provide a structured and organized way to design and build software systems. They encourage code reusability, modularity, and maintainability, making OOP a powerful paradigm for developing complex applications.

